---
layout:     post
title:      How to implement the MVC design pattern
date:       2016-2-19 14:58
summary:    A small model-view-controller demo with the Java Swing toolkit
categories: Java
---

When I first began to learn how write Swing applications, I ran into the issue of finding a good resource that clearly described ways to actually implement the Model-View-Controller. Most articles approached this design pattern from such a high-level perspective that they aren't helpful in actually demonstrating how to use the MVC in practice. 

This article aims at hitting all the angles by quickly discussing design patterns in general, why use them, describing the MVC from that high-level perspective, and then finally showing how the MVC can be done in practice with two action listeners – something I found that similar articles don't do.

# First, what is the MVC?

The MVC stands for the Model-View-Controller, which is just one of the many design patterns used by software developers today. Design patterns are basically a template that provides a solution to common software development problems. This doesn't mean that you *must* use the MVC or any other particular design pattern – they exist for when you need them. Another use for design patterns is that it provides a common language for developers so they can easily discuss how to develop their software.

### The goal of design patterns

Design patterns are generally developed around the principles of object-oriented design which works great with object-oriented languages such as Java, C++, Ruby, etc. Because of this, design patterns revolve around the concept of objects, where we abstract *things* to be represented in our code that can enhance the development, extensibility, and reliability of our software. In the realm of design patterns, most all components of the pattern will be discussed in terms of *objects*, which are simply classes or collections of classes to represent said pattern.

### So where does the MVC fit in?

The Model-View-Controller is a great solution in many GUI development situations. Note that it is not the only solution to GUI development – please understand this. There are also variations of the MVC such as the MVP and the MVVM, but the MVC seems to be the most ubiquitous now days so that is the one I'm here to discuss. The prevailing situation for using the MVC is where you're developing a GUI that allows users to interact with the interface, and where the program is going to have to do calculations, manipulate data, and store data and/or interact with a database.

### What it looks like

Here is the basic diagram of what the Model-View-Controller looks like in its abstract form. 

<center><a href="http://imgur.com/jI77oln"><img src="http://i.imgur.com/jI77olnl.png?1" title="MVC figure 1" /></a></center>

As you can see, we have three main components: the Model, the View, and the Controller. In any design pattern, each component has a distinct purpose – separate jobs – and the MVC is no different. It's very important to note the arrows and how there is no direct connection between the View and the Model. Remember this.

The last thing I'll add before we start on the demo, is that the Model, View, and Controller can each be represented through a collection of classes or a single class.

# How to implement the MVC

The actual demo for this article can be found [here](https://github.com/zakrywilson/mvc-demo) on my Github page. This project is literally for demonstration purposes so it's very slimmed down, but hopefully it will be enough that you can get the picture.

If you are looking at my Github project, you'll see how the Model, the View, and the Controller are broken up into distinct classes (`model.java`, `view.java`, and `controller.java`). This is probably the cleanest way to enforce that the three components are kept separate.

## The View

The View contains everything that the users will see. This means it contains text boxes, buttons, menus, windows, panels, etc. – the things the users sees and directly interacts with.

The View does not do any computation! If the user enters bad text into your text box, the View isn't going validate the data, do math for you, or access a database – it just displays data.

<script src="https://gist.github.com/zakrywilson/0c3890760fb771ef97fc.js"></script>

As you can see, we have five instance variables. These variables are the components that make up what the user sees. We have the frame that is the underlying object that is displayed. We have a panel that sits directly on top of the frame. We then have three components (two buttons and a text area) that lie on top of the panel. There is a little configuration for the display, found in the `display()` method; but apart from that, the View just looks like a glorified POJO with its *getters*. Again, the View isn't doing any computation, whatsoever; so with just the View, clicking buttons doesn't do anything now because that's not the View's job.

## The Controller

So now that we have the View, we just have a GUI that doesn't *do* anything. It's just a window with a couple buttons and a text area you can type in. How do we get the GUI to respond when a user presses a button? Well, that's where the Controller comes into play.

The Controller is like the puppet master behind your application. The View does not know about the Model, and the Model does not not about the View. But the Controller knows about both the Model and the View and *controls* both of them. For example, when the user presses the *clear* button we want the text in the text area to be removed. The sequence of events is commonly *user performs an action* –> *action listener notices action* –> *Controller responds by manipulating Model or View*. So, more specifically, on the backend when the *clear* button is pressed, the Controller is the one who recognizes that the *clear* button was pressed. The Controller then has a small amount of code that gets the button from the Model, and sets the text box to an empty string.

<script src="https://gist.github.com/zakrywilson/8abf89b76b57e090288f.js"></script>

Looking back at the View's constructor, we can see that the View only has instance variables that comprise the GUI – buttons, the text area, the frame, and the panel. It doesn't *know* about the Controller or the View. However, if we look at the constructor for the Controller, it takes an instance of the Model and an instance of the View. This is why it's the puppet master behind the GUI: it can control the View and the Model because it has instances of them.

So let's take another look at the *clear* button's functionality. The method `addClearButtonListener()` on line 66 is where the action listener for the *clear* button is created. Action listeners are interfaces that, when implemented, allow the programer to define what happens when that action listener notices an action. For our button, this means that when the button is clicked, the action listener sees this and the functionality, written inside its overridden `actionPerformed(ActionEvent)` method, is executed.

This is done by the Controller gaining access to the View's `getClearButton()` method. All JButtons have an inherited method called `addActionListener(ActionListener)` which is where the action listener is added to the button. 

On line 71, the Controller uses the View's `getTextArea()` method and calls `textArea`'s `setText(String)` method, setting the text area to an empty string. Notice how the View didn't do this by itself – the View merely possessed the getter for the text area. And for now, don't mind line 72.

In viewing `addShowButtonListener()` on line 43, the same process takes place where an action listener is added to `showButton`, residing in the Model; and access to the button is gained through the Model's methods.

## The Model

The purpose of the Model is to store and retrieve previously stored data. It also handles the heavy computation. The Model doesn't know about the Controller or the View either. It is manipulated via its methods by the Controller in the same way the View is controlled. 

<script src="https://gist.github.com/zakrywilson/5f38bbc6d73ed2ef589f.js"></script>

This Model is fairly simple: it is simply a POJO for the View's text area. If there were more sources for data, they would be stored here as well; but since we only have one data point, that's the only one inside the Model.

## Something to run it

Now it's not good design to have the Model, View, or Controller to *run* the program so we can make another class, which in this case is named GUI, to simply run the program.

<script src="https://gist.github.com/zakrywilson/1e6707b7aecf60ae5f5e.js"></script>

An instance of the Model and View are created and passed into the Controller to be controlled. 

# Summary

The MVC, when put together, results in a Controller controlling the View and the Model. The View displays all components and information to the user. The Model stores the data, handles heavy computation, and can interface with a database for example.

Here is how that might look at a high-level, and notice how the Controller isn't directory interacting with the user or database.

<center><a href="http://imgur.com/5Nn5LHT"><img src="http://i.imgur.com/5Nn5LHTl.png?2" title="MVC figure 2" /></a></center>

The Model-View-Controller design pattern provides developers with an elegant solution to designing a GUI. It can be very useful and extensible; but it is not the end-all solution to all GUI programs. If the project gets larger, classes that relate to the Model, View, and Controller can be placed in separate packages named *model*, *view*, and *controller*.

Hopefully this article cleared up any misconceptions about the MVC and how it can actually be implemented. It *really* isn't that complicated and it can be a very elegant solution to GUI applications. If you have any questions or comments, I'd love to hear them.

Thanks for reading!