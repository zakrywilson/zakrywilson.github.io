---
layout:     post
title:      How to implement the MVP design pattern
date:       2016-2-19 14:58
summary:    A small model-view-presenter demo with the Java Swing toolkit
categories: Java
---

When I first began to learn how write Swing applications, I ran into the issue of finding a good resource that clearly described ways to actually implement the Model-View-Presenter. Most articles approached this design pattern from such a high-level perspective that they aren't helpful in actually demonstrating how to use the MVP in practice.

This article aims at hitting all the angles by quickly discussing design patterns in general, why use them, describing the MVP from that high-level perspective, and then finally showing how the MVP can be done in practice with two action listeners – something I found that similar articles don't do.

This is small app we'll be creating in this article.

<center><img src="http://i.imgur.com/SWzbqGc.png" alt="GUI"></center>

# First, what is the MVP?

The MVP stands for the Model-View-Presenter, which is just one of the many design patterns used by software developers today. Design patterns are basically a template that provides a solution to common software development problems. This doesn't mean that you *must* use the MVP or any other particular design pattern – they exist for when you need them. Another use for design patterns is that it provides a common language for developers so they can easily discuss how to develop their software.

### The goal of design patterns

Design patterns are generally developed around the principles of object-oriented design which works great with object-oriented languages such as Java, C++, Ruby, etc. Because of this, design patterns revolve around the concept of objects, where we abstract *things* to be represented in our code that can enhance the development, extensibility, and reliability of our software. In the realm of design patterns, most all components of the pattern will be discussed in terms of *objects*, which are simply classes or collections of classes to represent said pattern.

### So where does the MVP fit in?

The Model-View-Presenter is a great solution in many GUI development situations. Note that it is not the only solution to GUI development – please understand this. There are also other variations such as the [MVC](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) and the [MVVM](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel); but when I first started making GUIs in Swing, the [MVP](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93presenter) seemed to make the most sense, so that's what I'm here to discuss. The prevailing situation for using the MVP is where you're developing a GUI that allows users to interact with an interface, and where the program is going to have to do calculations, manipulate data, and store data and/or interact with a database.

### What it looks like

Here is the basic diagram of what the Model-View-Presenter looks like in its abstract form.

<center><a href="https://imgur.com/Up6zv4d"><img src="https://i.imgur.com/Up6zv4d.png" title="MVP figure 1" /></a></center>

As you can see, we have three main components: the Model, the View, and the Presenter. In any design pattern, each component has a distinct purpose – separate jobs – and the MVP is no different. It's very important to note the arrows and how there is no direct connection between the View and the Model. Remember this.

The last thing I'll add before we start on the demo, is that the Model, View, and Presenter can each be represented through a collection of classes or a single class.

# How to implement the MVP

The actual demo for this article can be found [here](https://github.com/zakrywilson/mvp-demo) on my Github page. This project is literally for demonstration purposes so it's very slimmed down, but hopefully it will be enough that you can get the picture.

If you are looking at my Github project, you'll see how the Model, the View, and the Presenter are broken up into distinct classes (`model.java`, `view.java`, and `presenter.java`). This is probably the cleanest way to enforce that the three components are kept separate.

## The View

The View contains everything that the users will see. This means it contains text boxes, buttons, menus, windows, panels, etc. – the things the users sees and directly interacts with.

The View does not do any computation! If the user enters bad text into your text box, the View isn't going validate the data, do math for you, or access a database – it just displays data.

<script src="https://gist.github.com/zakrywilson/0c3890760fb771ef97fc.js"></script>

As you can see, we have five instance variables. These variables are the components that make up what the user sees. We have the frame that is the underlying object that is displayed. We have a panel that sits directly on top of the frame. We then have three components (two buttons and a text area) that lie on top of the panel. There is a little configuration for the display, found in the `display()` method; but apart from that, the View just looks like a glorified POJO with its *getters*. Again, the View isn't doing any computation, whatsoever; so with just the View, clicking buttons doesn't do anything now because that's not the View's job.

## The Presenter

So now that we have the View, we just have a GUI that doesn't *do* anything. It's just a window with a couple buttons and a text area you can type in. How do we get the GUI to respond when a user presses a button? Well, that's where the Presenter comes into play.

The Presenter is like the puppet master behind your application. The View does not know about the Model, and the Model does not not about the View. But the Presenter knows about both the Model and the View and controls both of them. For example, when the user presses the *clear* button we want the text in the text area to be removed. The sequence of events is commonly *user performs an action* –> *action listener notices action* –> *Presenter responds by manipulating Model or View*. So, more specifically, on the backend when the *clear* button is pressed, the Presenter is the one who recognizes that the *clear* button was pressed. The Presenter then has a small amount of code that gets the button from the Model, and sets the text box to an empty string.

<script src="https://gist.github.com/zakrywilson/8abf89b76b57e090288f.js"></script>

Looking back at the View's constructor, we can see that the View only has instance variables that comprise the GUI – buttons, the text area, the frame, and the panel. It doesn't *know* about the Presenter or the View. However, if we look at the constructor for the Presenter, it takes an instance of the Model and an instance of the View. This is why it's the puppet master behind the GUI: it can control the View and the Model because it has instances of them.

So let's take another look at the *clear* button's functionality. The method `addClearButtonListener()` on line 66 is where the action listener for the *clear* button is created. Action listeners are interfaces that, when implemented, allow the programer to define what happens when that action listener notices an action. For our button, this means that when the button is clicked, the action listener sees this and the functionality, written inside its overridden `actionPerformed(ActionEvent)` method, is executed.

This is done by the Presenter gaining access to the View's `getClearButton()` method. All JButtons have an inherited method called `addActionListener(ActionListener)` which is where the action listener is added to the button.

On line 71, the Presenter uses the View's `getTextArea()` method and calls `textArea`'s `setText(String)` method, setting the text area to an empty string. Notice how the View didn't do this by itself – the View merely possessed the getter for the text area. And for now, don't mind line 72.

In viewing `addShowButtonListener()` on line 43, the same process takes place where an action listener is added to `showButton`, residing in the Model; and access to the button is gained through the Model's methods.

## The Model

The purpose of the Model is to store and retrieve previously stored data. It also handles the heavy computation. The Model doesn't know about the Presenter or the View either. It is manipulated via its methods by the Presenter in the same way the View is controlled.

<script src="https://gist.github.com/zakrywilson/5f38bbc6d73ed2ef589f.js"></script>

This Model is fairly simple: it is simply a POJO for the View's text area. If there were more sources for data, they would be stored here as well; but since we only have one data point, that's the only one inside the Model.

The Model is used by the Presenter in `presenter.java` on line 72 where the Presenter resets the data stored within the Model by storing an empty string. The Model is used again inside the Presenter in the Presenter's `addShowButtonListener()` method on line 43. When the *show* button is pressed, the Presenter grabs the text from the View, and stores it in the Model, using their public methods. The Presenter then displays a dialog box, populating the box with the string that was stored within the Model.

## Something to run it

Now it's not good design to have the Model, View, or Presenter to *run* the program so we can make another class, which in this case is named GUI, to simply run the program.

<script src="https://gist.github.com/zakrywilson/1e6707b7aecf60ae5f5e.js"></script>

An instance of the Model and View are created and passed into the Presenter to be controlled.

## Putting it all together

And when we run it, this is our GUI. The user can write text in the text field, and when they press the *show* button, a dialog box is produced with the text from the text field.

![](http://i.imgur.com/aTnaQ6Z.png) ![](http://i.imgur.com/sz0N91e.png)

# Summary

The MVP, when put together, results in a Presenter controlling the View and the Model. The View displays all components and information to the user. The Model stores the data, handles heavy computation, and can interface with a database for example.

Here is how that might look at a high-level, and notice how the Presenter isn't directory interacting with the user or database.

<center><a href="https://imgur.com/kLPfaJs"><img src="https://i.imgur.com/kLPfaJs.png" title="MVP figure 2" /></a></center>

The Model-View-Presenter design pattern provides developers with an elegant solution to designing a GUI. It can be very useful and extensible; but it is not the end-all solution to all GUI programs. If the project gets larger, classes that relate to the Model, View, and Presenter can be placed in separate packages named *model*, *view*, and *presenter*.

Hopefully this article cleared up any misconceptions about the MVP and how it can actually be implemented. It *really* isn't that complicated and it can be a very elegant solution to GUI applications. If you have any questions or comments, I'd love to hear them.

Thanks for reading!
